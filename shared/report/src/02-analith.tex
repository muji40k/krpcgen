\leftsection{Аналитическая часть}

\vspace{-1\baselineskip}

\subsection{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать приложение,
генерирующее код загружаемых модулей ядра клиента и сервера, взаимодействующих
по протоколу ONC RPC, согласно описанной спецификации.

Для достижения поставленной цели необходимо решить следующие задачи:
\begin{enumerate}
    \item провести анализ составных частей протокола, способов представления и
          передачи информации;
    \item рассмотреть структуры и функции ядра, реализующие клиентскую и
          серверную стороны будущего приложения, определить порядок их
          инициализации и вызова;
    \item разработать алгоритм загружаемых модулей ядра;
    \item разработать алгоритм разбора файла спецификации и генерации
          соответствующих модулей на его основании;
    \item проанализировать результаты работы разработанного приложения.
\end{enumerate}

\subsection{Анализ протокола ONC RPC}

\subsubsection{Описание модели взаимодействия}

\subsubsection{Структурные части}

\subsubsection{Описание типов данных}

\subsection{Поддержка в ядре Linux}

В ядре реализация RPC представлена в составе модуля \code{sunrpc}, который
может быть скомпилирован как часть ядра или загружаемый модуль.

Перед использованием, модуль должен быть загружен при помощи команды
\code{modprobe sunrpc}, после чего разработчику становится доступна кодовая
база для написания клиента и сервера приложения. В дальнейшем, структуры и
функции будут рассматриваться для версии ядра 6.12.7~\cite{LinuxKernel6127}.

\subsubsection{Инициализация и порядок работы сервера}

Сервер описывается структурой \code{svc_serv} (листинг~\ref{lst:struct_svc_serv})
и называется сервисом, который в свою очередь является демоном, отвечающим за
прием и обработку сообщений, а так же поддержание потоков обработчиков.

\begin{lstlisting}[caption={Структура сервиса}, label={lst:struct_svc_serv}]
struct svc_serv {
    /* Массив программ и его размер */
    struct svc_program *    sv_programs;
    unsigned int            sv_nprogs;
    /* Число потоков обработчиков */
    unsigned int        sv_nrthreads;
    /* Максимальное количество соединений.
     * Равно числу потоков, если указан 0 */
    unsigned int        sv_maxconn;
    struct svc_stat *   sv_stats;
    spinlock_t          sv_lock;
    /* Размеры буфера и сообщения */
    unsigned int        sv_max_payload;
    unsigned int        sv_max_mesg;
    unsigned int        sv_xdrsize;
    /* Списки сокетов */
    struct list_head    sv_permsocks;
    struct list_head    sv_tempsocks;
    int                 sv_tmpcnt;
    struct timer_list   sv_temptimer;
    char *          sv_name;
    /* Пул потоков */
    unsigned int        sv_nrpools;
    bool                sv_is_pooled;
    struct svc_pool *   sv_pools;
    /* Функция потока обработчика */
    int         (*sv_threadfn)(void *data);
#if defined(CONFIG_SUNRPC_BACKCHANNEL)
    struct lwq      sv_cb_list;
    bool            sv_bc_enabled;
#endif /* CONFIG_SUNRPC_BACKCHANNEL */
};
\end{lstlisting}

Сервис может быть создан в однопоточном или многопоточном варианте с
использованием функций \code{svc_create} и \code{svc_create_pooled}
(листинг~\ref{lst:svc_create}), которые приводят последующему вызову
\code{__svc_create}. Функция создает и инициализирует структуру
\code{svc_serv}, из примечательных моментов, максимальный размер сообщения
\code{sv_max_payload} имеет значение по умолчанию, равное одной странице (при
использовании значения 0 для параметра \code{bufsize}).

\begin{lstlisting}[caption={Создание сервиса}, label={lst:svc_create}]
struct svc_serv *svc_create(struct svc_program *prog,
                            unsigned int bufsize,
                            int (*threadfn)(void *data));
struct svc_serv *svc_create_pooled(struct svc_program *prog,
                                   unsigned int nprog,
                                   struct svc_stat *stats,
                                   unsigned int bufsize,
                                   int (*threadfn)(void *data));
\end{lstlisting}

Программа, ее версии и процедуры описываются следующими структурами,
представленными на листингах
\refrange{lst:struct_svc_program}{lst:struct_svc_procedure}. Соответствующие
массивы версий и процедур могут быть определены как статически, так и
динамически.

\begin{lstlisting}[caption={Структура программы}, label={lst:struct_svc_program}]
struct svc_program {
    /* Номер программы */
    u32         pg_prog;
    /* Минимальная и максимальная обслуживаемые версии */
    unsigned int        pg_lovers;
    unsigned int        pg_hivers;
    /* Массива версий и его размер */
    unsigned int        pg_nvers;
    const struct svc_version **pg_vers;
    /* Название программы */
    char *          pg_name;
    /* Название класса прграмм, разделяющих аутентификацию,
     * используется общий кеш */
    char *          pg_class;
    /* Пользовательский обработчик аутентификации */
    enum svc_auth_status    (*pg_authenticate)(struct svc_rqst *rqstp);
    /* Функция инициализации контекста потока */
    __be32          (*pg_init_request)(struct svc_rqst *,
                           const struct svc_program *,
                           struct svc_process_info *);
    /* Функция регистрации сервиса (portmapper) */
    int         (*pg_rpcbind_set)(struct net *net,
                          const struct svc_program *,
                          u32 version, int family,
                          unsigned short proto,
                          unsigned short port);
};
\end{lstlisting}

\begin{lstlisting}[caption={Структура версии}, label={lst:struct_svc_version}]
struct svc_version {
    /* Номер версии */
    u32         vs_vers;
    /* Массив процедур и их количество */
    const struct svc_procedure *vs_proc;
    u32                         vs_nproc;
    unsigned long __percpu  *vs_count;
    /* Размер буфера сообщения */
    u32         vs_xdrsize;
    /* Используется ли portmapper */
    bool            vs_hidden;
    /* Игнорируется ли ошибка регистрации */
    bool            vs_rpcb_optnl;
    bool            vs_need_cong_ctrl;
    /* Функция диспетчеризации */
    int         (*vs_dispatch)(struct svc_rqst *rqstp);
};
\end{lstlisting}

\begin{lstlisting}[caption={Структура процедуры}, label={lst:struct_svc_procedure}]
struct svc_procedure {
    /* Реализация функции обработчика процедуры */
    __be32          (*pc_func)(struct svc_rqst *);
    /* Кодирование и декодирование */
    bool            (*pc_decode)(struct svc_rqst *rqstp,
                         struct xdr_stream *xdr); // аргументы
    bool            (*pc_encode)(struct svc_rqst *rqstp,
                         struct xdr_stream *xdr); // результат
    /* Очистка использованных значений */
    void            (*pc_release)(struct svc_rqst *);
    /* Размер аргумента и количество байт, которые должны быть очищены */
    unsigned int        pc_argsize;
    unsigned int        pc_argzero;
    /* Размер результата и максимальный размер сообщения */
    unsigned int        pc_ressize;
    unsigned int        pc_xdrressize;
    unsigned int        pc_cachetype;
    const char *        pc_name;
};
\end{lstlisting}

Инициализация сервиса не приводит к его регистрации, запуску или созданию
транспортной инфраструктуры. Типичная последовательность запуска представлена
на листинге~\ref{lst:svc_start_proc}.

\begin{lstlisting}[caption={Последовательность регистрации и запуска сервиса}, label={lst:svc_start_proc}]
// 1
int svc_bind(struct svc_serv *serv, struct net *net);
// 2
int svc_xprt_create(struct svc_serv *serv, const char *xprt_name,
                    struct net *net, const int family,
                    const unsigned short port, int flags,
                    const struct cred *cred);
// 3
int svc_set_num_threads(struct svc_serv *serv, struct svc_pool *pool,
                        int nrservs);
\end{lstlisting}

Вызов \code{svc_bind}, вопреки названию, не регистрирует сервис у portmapper,
но удаляет существующие записи других сервисов, если они использую номера вновь
созданной программы.

Регистрация же производится при создании нового транспорта в функции
\code{svс_xprt_create}. Зарегистрированные протоколы содержатся в списке
\code{svc_xprt_class_list} и описываются структурой \code{svc_xprt_class}
(листинг~\ref{lst:struct_svc_xprt_class}). В настоящий момент возможно
использовать только TCP или UDP. Вызов \code{svc_xprt_create} осуществляет
поиск транспорта по его названию, переданному параметром \code{xprt_name},
после чего вызывается метод \code{xpo_create}, значение которого совпадает для
обоих протоколов --- \code{svc_create_socket}. Функция создает сокет
(\code{__sock_create}), связывает его с переданным адресом
(\code{kernel_bind}) и вызывает \code{setup_socket}, где и происходит
регистрация нового сервиса вызовом \code{svc_register}, который вызывает метод
\code{pg_rpcbind_set} текущей программы для каждой ее версии. При
использовании rpcbind, в ядре определена стандартная реализация метода ---
\code{svc_generic_rpcbind_set}.

\begin{lstlisting}[caption={Структура транспортного протокола и операции над ним}, label={lst:struct_svc_xprt_class}]
struct svc_xprt_class {
    const char                *xcl_name;
    struct module             *xcl_owner;
    const struct svc_xprt_ops *xcl_ops;
    struct list_head           xcl_list;
    u32                        xcl_max_payload;
    int                        xcl_ident;
};
struct svc_xprt_ops {
    struct svc_xprt *(*xpo_create)(struct svc_serv *,
                                   struct net *net,
                                   struct sockaddr *, int,
                                   int);
    struct svc_xprt *(*xpo_accept)(struct svc_xprt *);
    int              (*xpo_has_wspace)(struct svc_xprt *);
    int              (*xpo_recvfrom)(struct svc_rqst *);
    int              (*xpo_sendto)(struct svc_rqst *);
    int              (*xpo_result_payload)(struct svc_rqst *,
                                           unsigned int,
                                           unsigned int);
    void             (*xpo_release_ctxt)(struct svc_xprt *xprt,
                                         void *ctxt);
    void             (*xpo_detach)(struct svc_xprt *);
    void             (*xpo_free)(struct svc_xprt *);
    void             (*xpo_kill_temp_xprt)(struct svc_xprt *);
    void             (*xpo_handshake)(struct svc_xprt *xprt);
};
\end{lstlisting}

После чего остается запустить обработчик функцией \\
\code{svc_set_num_threads}. Вызов создает поток ядра и начинает выполнять
функцию из поля \code{sv_threadfn} сервиса. Ядро не предоставляет готовых
решений для обработчика, поэтому его необходимо определить самостоятельно.
Минимальный пример реализации представлен на листинге \ref{lst:threadfn}.

\begin{lstlisting}[caption={Минимальная реализация функции потока}, label={lst:threadfn}]
int threadfn(void *data) {
    struct svc_rqst *rqstp = data;
    svc_thread_init_status(rqstp, 0);

    while (!svc_thread_should_stop(rqstp)) {
        svc_recv(rqstp);
    }

    svc_exit_thread(rqstp);

    return 0;
}
\end{lstlisting}

После инициализации в начале обработчика необходимо вызвать функцию
\code{svc_thread_init_status}, передающую статус основному потоку, позволяя ему
продолжить работу. В случае заявления ошибки, функция также останавливает и
поток обработчика. Далее идет основной поток обработки запросов:
\code{svc_thread_should_stop} --- проверяет необходимо ли завершить поток
обработчик; \code{svc_recv} --- получает запрос и вызывает обработчик
\code{svc_process}, если в настоящий момент нет доступных запросов, то поток
переключается в состояние idle.

Работа сервиса прекращается повторным вызовом функции \\
\code{svc_set_num_threads} c параметром \code{nrservs} равным 0. Получив сигнал
к завершению (установкой бита \code{SP_NEED_VICTIM}), поток должен прекратить
работу и вызвать \code{svc_exit_thread} для очистки контекста потока и
информирования основного потока о завершении (сброс бита
\code{SP_VICTIM_REMAINS}).

Обработка запроса происходит внутри функции \code{svc_process}, алгоритм
которой представлен на
рисунках~\refrange{fig:algorithm_svc_process}{fig:algorithm_svc_process_common_2}.

\clearpage
\vspace*{\fill}
\begin{figure}[!h]
    \centering
    \def\svgwidth{\textwidth}
    \input{svc_process_pt1.pdf_tex}
    \caption{Схема алгоритма функции \code{svc_process}}
    \label{fig:algorithm_svc_process}
\end{figure}
\vfill

\clearpage
\vspace*{\fill}
\begin{figure}[!h]
    \centering
    \def\svgwidth{\textwidth}
    \input{svc_process_pt2.pdf_tex}
    \caption{Схема алгоритма функции \code{svc_process_common} (часть 1)}
    \label{fig:algorithm_svc_process_common_1}
\end{figure}
\vfill

\clearpage
\vspace*{\fill}
\begin{figure}[!h]
    \centering
    \def\svgwidth{\textwidth}
    \input{svc_process_pt3.pdf_tex}
    \caption{Схема алгоритма функции \code{svc_process} (часть 2)}
    \label{fig:algorithm_svc_process_common_2}
\end{figure}
\vfill

\clearpage

Шаблонная реализация метода программы \code{pg_init_request} представлена в
функции \code{svc_generic_init_request} и выполняет следующие задачи:
\begin{itemize}
    \item проверка существования запрашиваемой версии и процедуры;
    \item получение структуры \code{svc_procedure} (поле \code{rq_procinfo});
    \item инициализация полей аргумента и результата
          (\code{rq_argp} и \code{rq_resp});
    \item получение функции диспетчеризации (\code{vs_dispatch}).
\end{itemize}

Для функции диспетчеризации не предусмотрено готовое решение, однако из
алгоритма обработки запроса видно, что остается преобразовать полученные
аргументы (\code{pc_decode}), выполнить функцию обработчик запрашиваемой
процедуры (\code{pc_func}) и закодировать результат (\code{pc_encode}).
Минимальный пример такой функции представлен в листинге~\ref{lst:dispatch}.

\begin{lstlisting}[caption={Минимальная реализация функции диспетчеризации}, label={lst:dispatch}]
int dispatch(struct svc_rqst *rqstp) {
    const struct svc_procedure *proc = rqstp->rq_procinfo;
    __be32 *statp = rqstp->rq_accept_statp;
    if (!proc->pc_decode(rqstp, &rqstp->rq_arg_stream)) {
        *statp = rpc_garbage_args;
        return 0;
    }
    *statp = proc->pc_func(rqstp);
    if (!proc->pc_encode(rqstp, &rqstp->rq_res_stream)) {
        *statp = rpc_system_err;
        return 0;
    }
    return 1;
}
\end{lstlisting}

\subsubsection{Порядок выполнения запроса}

Аналогичные структуры для описания программы определены и для клиента
(листинги~\refrange{lst:struct_rpc_program}{lst:struct_rpc_procedure}).

\clearpage

\begin{lstlisting}[caption={Структура программы}, label={lst:struct_rpc_program}]
struct rpc_program {
    /* Название программы */
    const char *                name;
    /* Номер программы */
    u32                         number;
    /* Массив версий и их количество */
    const struct rpc_version ** version;
    unsigned int                nrvers;
    struct rpc_stat *           stats;
    const char *                pipe_dir_name;
};
\end{lstlisting}

\begin{lstlisting}[caption={Структура версии}, label={lst:struct_rpc_version}]
struct rpc_version {
    /* Номер версии */
    u32                        number;
    /* Массив процедур и их количество */
    const struct rpc_procinfo *procs;
    unsigned int               nrprocs;
    /* Количество вызовов */
    unsigned int              *counts;
};
\end{lstlisting}

\begin{lstlisting}[caption={Структура процедуры}, label={lst:struct_rpc_procedure}]
struct rpc_procinfo {
    /* Номер процедуры */
    u32          p_proc;
    /* Кодирование аргументов */
    kxdreproc_t  p_encode;
    /* Декодирование результатов */
    kxdrdproc_t  p_decode;
    /* Размер */
    unsigned int p_arglen; /* аргумент */
    unsigned int p_replen; /* результат */
    /* Ожидаемое время задержки */
    unsigned int p_timer;
    u32          p_statidx;
    /* Название процедуры */
    const char  *p_name;
};
\end{lstlisting}

Для вызова процедуры необходимо вызвать одну из следующих функций оберток,
представленных в листинге~\ref{lst:rpc_call}. Или же инициализировать и
запустить задачу, описываемую структурой \code{rpc_task}, вручную
(листинг~\ref{lst:rpc_task}).

\begin{lstlisting}[caption={Прототип функций вызова удаленных процедур}, label={lst:rpc_call}]
// Содержимое вызова
struct rpc_message {
    /* Информация о процедуре */
    const struct rpc_procinfo *rpc_proc;
    /* Аргументы */
    void *                     rpc_argp;
    /* Результат */
    void *                     rpc_resp;
    const struct cred *        rpc_cred;
};

// Функции обратного вызова
struct rpc_call_ops {
    void (*rpc_call_prepare)(struct rpc_task *, void *);
    void (*rpc_call_done)(struct rpc_task *, void *);
    void (*rpc_count_stats)(struct rpc_task *, void *);
    void (*rpc_release)(void *);
};

int     rpc_call_async(struct rpc_clnt *clnt,
                       const struct rpc_message *msg,
                       int flags,
                       const struct rpc_call_ops *tk_ops,
                       void *calldata);
int     rpc_call_sync(struct rpc_clnt *clnt,
                      const struct rpc_message *msg, int flags);
\end{lstlisting}

\begin{lstlisting}[caption={Структура \code{rpc_task}}, label={lst:rpc_task}]
struct rpc_task_setup {
    struct rpc_task           *task;
    struct rpc_clnt           *rpc_client;
    struct rpc_xprt           *rpc_xprt;
    struct rpc_cred           *rpc_op_cred;
    const struct rpc_message  *rpc_message;
    const struct rpc_call_ops *callback_ops;
    void                      *callback_data;
    struct workqueue_struct   *workqueue;
    unsigned short             flags;
    signed char                priority;
};

struct rpc_task *rpc_run_task(const struct rpc_task_setup *);
\end{lstlisting}

Вызов процедуры описан конечной машиной состояний. Возможные состояния задачи и
переходы между ними представлены в таблицах~\ref{tbl:rpc_task_states}
и~\ref{tbl:rpc_task_state_transfers}.

\clearpage

\begin{table}[htb!]
    \centering
    \begin{threeparttable}
        \caption{Состояния задачи}
        \begin{tabular}{|r|l|l|}
        \hline
        \multicolumn{1}{|c|}{Номер} & \multicolumn{1}{c|}{Название} & \multicolumn{1}{c|}{Назначение}                                                               \\ \hline
        1                           & call\_start                   & Начальное состояние                                                                           \\ \hline
        2                           & call\_reserve                 & Выделение слота транспортного протокола                                                       \\ \hline
        3                           & call\_reserveresult           & Проверка выделенного слота                                                                    \\ \hline
        4                           & call\_retry\_reserve          & Повторная попытка выделения слота                                                             \\ \hline
        5                           & call\_refresh                 & Обновление удостоверяющей информации                                                          \\ \hline
        6                           & call\_refreshresult           & Проверка удостоверяющей информации                                                            \\ \hline
        7                           & call\_allocate                & Выделение буфера                                                                              \\ \hline
        8                           & call\_encode                  & Кодирование аргументов                                                                        \\ \hline
        9                           & call\_bind                    & Получение порта программы                                                                     \\ \hline
        10                          & call\_connect                 & Соединение с сервером                                                                         \\ \hline
        11                          & call\_bind\_status            & Обработка релультатов rpcbind                                                                 \\ \hline
        12                          & call\_connect\_status         & Обработка результата соединения                                                               \\ \hline
        13                          & call\_transmit                & Отправка запроса                                                                              \\ \hline
        14                          & call\_transmit\_status        & Проверка статуса передачи                                                                     \\ \hline
        15                          & call\_status                  & Проверка статуса запроса                                                                      \\ \hline
        16                          & call\_decode                  & Декодирование результата                                                                      \\ \hline
        17                          & rpc\_exit\_task               & \begin{tabular}[c]{@{}l@{}}Фиктивное состояние завершения\\ и разрушения запроса\end{tabular} \\ \hline
        \end{tabular}
        \label{tbl:rpc_task_states}
    \end{threeparttable}
\end{table}

\vspace{\fill}

\begin{table}[htb!]
    \centering
    \begin{threeparttable}
        \caption{Переходы состояний задачи}
\begin{tabular}{|R{0.15\textwidth}|R{0.08\textwidth}|L{0.65\textwidth}|}
\hline
\multicolumn{1}{|c|}{Инициатор} & \multicolumn{1}{c|}{Цель} & \multicolumn{1}{c|}{Причина (при наличии)}                                                                       \\ \hline
\multirow{2}{*}{1}              & 2                         & Иначе                                                                                                            \\ \cline{2-3} 
                                & 17                        & Клиент выключен                                                                                                  \\ \hline
2                               & 3                         & \multicolumn{1}{c|}{-}                                                                                           \\ \hline
\multirow{3}{*}{3}              & 4                         & Не удалось выделить слот (EAGAIN | ENOMEM)                                                                       \\ \cline{2-3} 
                                & 5                         & Слот выделен                                                                                                     \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
4                               & 3                         & \multicolumn{1}{c|}{-}                                                                                           \\ \hline
5                               & 6                         & \multicolumn{1}{c|}{-}                                                                                           \\ \hline
\multirow{4}{*}{6}              & \multirow{2}{*}{5}        & ENOMEM                                                                                                           \\ \cline{3-3} 
                                &                           & Просроченное удостоверение                                                                                       \\ \cline{2-3} 
                                & 7                         & Актуальное удостоверение                                                                                         \\ \cline{2-3} 
                                & 17                        & Превышено число повторений                                                                                       \\ \hline
\multirow{3}{*}{7}              & 7                         & \begin{tabular}[c]{@{}l@{}}RPC\_IS\_ASYNC\\ и не получен фатальный сигнал\end{tabular}                           \\ \cline{2-3} 
                                & 8                         & Буфер выделен                                                                                                    \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
\end{tabular}
        \label{tbl:rpc_task_state_transfers}
    \end{threeparttable}
\end{table}

\begin{table}[htb!]
    \centering
    \begin{threeparttable}
Продолжение таблицы~\ref{tbl:rpc_task_state_transfers}
\begin{tabular}{|R{0.15\textwidth}|R{0.08\textwidth}|L{0.65\textwidth}|}
\hline
\multirow{5}{*}{8}              & 9                         & Порт сервиса не получен                                                                                          \\ \cline{2-3} 
                                & 10                        & Соединение не установлено                                                                                        \\ \cline{2-3} 
                                & 13                        & \begin{tabular}[c]{@{}l@{}}Кодирование успешно\\ и соединениеустановлено\end{tabular}                            \\ \cline{2-3} 
                                & \multirow{2}{*}{17}       & Не удалось закодировать заголовок                                                                                \\ \cline{3-3} 
                                &                           & Иная ошибка                                                                                                      \\ \hline
\multirow{3}{*}{9}              & 10                        & Порт уже получен                                                                                                 \\ \cline{2-3} 
                                & 11                        & Иначе                                                                                                            \\ \cline{2-3} 
                                & 14                        & Запрос уже отправлен                                                                                             \\ \hline
\multirow{3}{*}{10}             & 12                        & Иначе                                                                                                            \\ \cline{2-3} 
                                & 13                        & Соединение уже установлено                                                                                       \\ \cline{2-3} 
                                & 14                        & Запрос уже отправлен                                                                                             \\ \hline
\multirow{5}{*}{11}             & \multirow{2}{*}{9}        & \begin{tabular}[c]{@{}l@{}}Некритичная ошибка\\ (ENOMEM | EACCESS | ENOBUFS | EAGAIN\\ | ETIMEDOUT)\end{tabular} \\ \cline{3-3} 
                                &                           & \begin{tabular}[c]{@{}l@{}}Сетевая ошибка\\ (если сброшен флаг SOFTCONN)\end{tabular}                            \\ \cline{2-3} 
                                & 10                        & Порт получен                                                                                                     \\ \cline{2-3} 
                                & 14                        & Запрос уже отправлен                                                                                             \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
\multirow{5}{*}{12}             & \multirow{2}{*}{9}        & \begin{tabular}[c]{@{}l@{}}Некритичная ошибка\\ (ENOBUFS | EAGAIN| ETIMEDOUT)\end{tabular}                       \\ \cline{3-3} 
                                &                           & \begin{tabular}[c]{@{}l@{}}Сетевая ошибка\\ (если сброшен флаг SOFTCONN)\end{tabular}                            \\ \cline{2-3} 
                                & 13                        & Соединение установлено                                                                                           \\ \cline{2-3} 
                                & 14                        & Запрос уже отправлен                                                                                             \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
13                              & 14                        & \multicolumn{1}{c|}{-}                                                                                           \\ \hline
\multirow{5}{*}{14}             & 8                         & EBADMSG                                                                                                          \\ \cline{2-3} 
                                & 9                         & ENOMEM | ENOBUFS | EBADSLT | EAGAIN                                                                              \\ \cline{2-3} 
                                & 13                        & \begin{tabular}[c]{@{}l@{}}Сетевая ошибка\\ (если сброшен флаг SOFTCONN)\end{tabular}                            \\ \cline{2-3} 
                                & 15                        & Запрос передан                                                                                                   \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
\multirow{4}{*}{15}             & \multirow{2}{*}{8}        & \begin{tabular}[c]{@{}l@{}}Сетевая ошибка\\ (если сброшен флаг SOFTCONN)\end{tabular}                            \\ \cline{3-3} 
                                &                           & EAGAIN | ENFILE | ENOBUFS | ENOMEM                                                                               \\ \cline{2-3} 
                                & 16                        & Запрос выполнен успешно                                                                                          \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
\end{tabular}
    \end{threeparttable}
\end{table}

\clearpage

\begin{table}[htb!]
    \centering
    \begin{threeparttable}
Продолжение таблицы~\ref{tbl:rpc_task_state_transfers}
\begin{tabular}{|R{0.15\textwidth}|R{0.08\textwidth}|L{0.65\textwidth}|}
\hline
\multirow{4}{*}{16}             & 2                         & EKEYREJECTED                                                                                                     \\ \cline{2-3} 
                                & 8                         & EAGAIN                                                                                                           \\ \cline{2-3} 
                                & \multirow{2}{*}{17}       & Результат декодирован успешно                                                                                    \\ \cline{3-3} 
                                &                           & Иная ошибка                                                                                                      \\ \hline
\end{tabular}
    \end{threeparttable}
\end{table}

Вне зависимости от выбранного подхода предварительно необходимо создать
объект клиента --- структуру \code{rpc_clnt}, вызовом функции \code{rpc_create}
(листинг~\ref{lst:rpc_create}).

\begin{lstlisting}[caption={Создание клиента}, label={lst:rpc_create}]
struct rpc_create_args {
    struct net               *net;
    int                       protocol;
    struct sockaddr          *address;
    size_t                    addrsize;
    const struct rpc_program *program;
    u32                       version;
    rpc_authflavor_t          authflavor;
    const struct cred        *cred;
    unsigned long             flags;

    struct sockaddr          *saddress;
    const struct rpc_timeout *timeout;
    const char               *servername;
    const char               *nodename;
    struct rpc_stat          *stats;
    u32                       prognumber;
    u32                       nconnect;
    char                     *client_name;
    struct svc_xprt          *bc_xprt;
    unsigned int              max_connect;
    struct xprtsec_parms      xprtsec;
    unsigned long             connect_timeout;
    unsigned long             reconnect_timeout;
};

struct rpc_clnt *rpc_create(struct rpc_create_args *args);
\end{lstlisting}

\subsubsection{Преобразование аргументов и результата}

\subsection*{Вывод}

