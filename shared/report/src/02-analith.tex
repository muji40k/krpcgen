\leftsection{Аналитическая часть}

\vspace{-1\baselineskip}

\subsection{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать приложение,
генерирующее код загружаемых модулей ядра клиента и сервера, взаимодействующих
по протоколу ONC RPC, согласно описанной спецификации.

Для достижения поставленной цели необходимо решить следующие задачи:
\begin{enumerate}
    \item провести анализ составных частей протокола, способов представления и
          передачи информации;
    \item рассмотреть структуры и функции ядра, реализующие клиентскую и
          серверную стороны будущего приложения, определить порядок их
          инициализации и вызова;
    \item разработать алгоритм загружаемых модулей ядра;
    \item разработать алгоритм разбора файла спецификации и генерации
          соответствующих модулей на его основании;
    \item проанализировать результаты работы разработанного приложения.
\end{enumerate}

\subsection{Анализ протокола ONC RPC}

Программа реализующая протокол ONC RPC называется сервисом и предоставляет
доступ к одной или нескольким программам, которые, в свою очередь, реализуют
одну или несколько удаленных процедур. Процедуры, их параметры и результаты
документированы в спецификации протокола конкретной программы. Сервис
поддерживает версионирование программ для поддержания совместимости с
изменяющимися протоколами~\cite{rfc5531}.

\subsubsection{Анализ модели взаимодействия}

Протокол ONC RPC основан на модели удаленного вызова процедур, которая
аналогична модели локального вызова процедур, за исключением того, что поток
управления проходит через два процесса: клиента и сервера~\cite{rfc5531}.
Клиент посылает сообщение серверу и блокируется до получения ответа. Сообщение
вызова содержит параметры процедуры, а ответа --- результаты работы процедуры.
Когда ответ получен, результаты процедуры извлекаются, и процесс на клиентской
стороне возобновляется.

Ожидая поступления сообщений, процесс сервера засыпает, а при получении ---
извлекает параметры процедуры, вызывает обработчик для вычисления результата и
отправляет ответ.

Таким образом с каждый момент времени активен только один процесс, однако
протокол не накладывает никаких ограничений на реализуемую модель, и возможны
другие варианты организации параллельных вычислений~\cite{rfc5531}.

Протокол RPC может быть реализован для различных транспортных протоколов, при
этом реализация протокола не регламентирует передачу сообщений от одного
процесса к другому и включает в себя только спецификацию и способ интерпретации
сообщений. Привязки конкретного клиента к конкретному сервису и транспортными
параметрами также не является частью протокола RPC~\cite{rfc5531}. Для этого
используются специальные приложения \code{portmapper}, в частности
\code{rpcbind}, для связи информации о доступных сервисах и способах доступа к
ним~\cite{rfc1833}.

\subsubsection{Анализ структурных частей протокола}

Как уже было описано ранее сервис состоит из программ, которые содержат
некоторое количество процедур, потенциально различных версий. Для их описания
используется спецификация на языке RPC Language, который является расширением
стандарта XDR для кодирования данных~\mbox{\cite{rfc5531}\cite{rfc4506}}.
Грамматика расширения языка представлена на листинге~\ref{lst:rpcl} в
форме Бэкуса-Наура.

\begin{lstlisting}[caption={Структура RPCL}, label={lst:rpcl}]
program-def:
    "program" identifier "{"
        version-def
        version-def *
    "}" "=" constant ";"
version-def:
    "version" identifier "{"
        procedure-def
        procedure-def *
    "}" "=" constant ";"
procedure-def:
    proc-return identifier "("
        proc-firstarg ("," type-specifier )*
    ")" "=" constant ";"
proc-return: "void" | type-specifier
proc-firstarg: "void" | type-specifier
\end{lstlisting}

Ограничения~\cite{rfc5531}:
\begin{itemize}
    \item ключевые слова \code{program} и \code{version} не могут быть
          использованы как идентификаторы;
    \item идентификаторы программы и связанные с ними номера не могут
          повторяться в контексте спецификации;
    \item идентификаторы и связанные с ними номера версии не могут
          повторяться в контексте программы;
    \item идентификаторы и связанные с ними номера процедуры не могут
          повторяться в контексте версии;
    \item в качестве номеров могут быть использованы только беззнаковые
          целые числа.
\end{itemize}

\subsubsection{Анализ типов данных стандарта XDR}

Стандарт XDR в свою очередь предоставляет не только язык для описания типов
данных, но и формат для их представления. Структура описания XDR представлена
на листинге~\ref{lst:xdrl}.

\clearpage

\begin{lstlisting}[caption={Структура XDR}, label={lst:xdrl}]
declaration:
    type-specifier identifier
    | type-specifier identifier "[" value "]"
    | type-specifier identifier "<" [ value ] ">"
    | "opaque" identifier "[" value "]"
    | "opaque" identifier "<" [ value ] ">"
    | "string" identifier "<" [ value ] ">"
    | type-specifier "*" identifier
    | "void"
value:
    constant | identifier
type-specifier:
    [ "unsigned" ] "int" | [ "unsigned" ] "hyper"
    | "float" | "double" | "quadruple"
    | "bool"
    | enum-type-spec | struct-type-spec | union-type-spec
    | identifier
enum-type-spec:
    "enum" enum-body
enum-body:
    "{" ( identifier "=" value ) ( "," identifier "=" value )* "}"
struct-type-spec:
    "struct" struct-body
struct-body:
    "{" ( declaration ";" ) ( declaration ";" )* "}"
union-type-spec:
    "union" union-body
union-body:
    "switch" "(" declaration ")" "{"
    ( "case" value ":" declaration ";" )
    ( "case" value ":" declaration ";" )*
    [ "default" ":" declaration ";" ]
    "}"
constant-def:
    "const" identifier "=" constant ";"
type-def:
    "typedef" declaration ";"
    | "enum" identifier enum-body ";"
    | "struct" identifier struct-body ";"
    | "union" identifier union-body ";"
definition:
    type-def | constant-def
specification:
    definition *
\end{lstlisting}

\clearpage

Нотация копирует синтаксис языка C, с добавлением некоторых
особенностей~\cite{rfc4506}:
\begin{itemize}
    \item нотация \code{"<" [ value ] ">"} означает массив переменной длины с
          возможным ограничением максимального количества элементов в
          \code{value} элементов;
    \item аналог объявления указателя из языка C, означает необязательное поле
          и кодируется как массив переменной длины с ограничением в 1 элемент;
    \item данные с типом \code{opaque} передаются без изменений (как массив
          байт);
    \item строка \code{string} нуль терминирована и передается как массив байт;
    \item \code{bool} --- беззнаковое целое;
    \item вещественные числа передаются как есть, так как документированы
          стандартом IEEE 754.
\end{itemize}

Для представления данных XDR использует порядок байт от старшего к младшему и
объединяет данные в блоки по 4 байта, поэтому длина любого сообщения должна
быть кратна 4. Элементы массивов, структур кодируются в порядке описания
(появления). В случае передачи массивов переменной длины, их размер
записывается перед телом как беззнаковое 4 байтовое целое. Дискриминант
объединения также записывается перед телом, аналогично как 4 байтовое
целое~\cite{rfc4506}.

\subsection{Анализ поддержки в ядре Linux}

В ядре реализация RPC представлена в составе модуля \code{sunrpc}, который
может быть скомпилирован как часть ядра или загружаемый модуль.

Перед использованием, модуль должен быть загружен при помощи команды
\code{modprobe sunrpc}, после чего разработчику становится доступна кодовая
база для написания клиента и сервера приложения. В дальнейшем, структуры и
функции будут рассматриваться для версии ядра 6.12.7~\cite{LinuxKernel6127}.

\subsubsection{Анализ инициализации и порядка работы сервера}

Сервер описывается структурой \code{svc_serv}
(листинг~\ref{lst:struct_svc_serv}) и называется сервисом, который в свою
очередь является демоном, отвечающим за прием и обработку сообщений, а так же
поддержание потоков обработчиков.

\begin{lstlisting}[caption={Структура сервиса}, label={lst:struct_svc_serv}]
struct svc_serv {
    /* Массив программ и его размер */
    struct svc_program *    sv_programs;
    unsigned int            sv_nprogs;
    /* Число потоков обработчиков */
    unsigned int        sv_nrthreads;
    /* Максимальное количество соединений.
     * Равно числу потоков, если указан 0 */
    unsigned int        sv_maxconn;
    struct svc_stat *   sv_stats;
    spinlock_t          sv_lock;
    /* Размеры буфера и сообщения */
    unsigned int        sv_max_payload;
    unsigned int        sv_max_mesg;
    unsigned int        sv_xdrsize;
    /* Списки сокетов */
    struct list_head    sv_permsocks;
    struct list_head    sv_tempsocks;
    int                 sv_tmpcnt;
    struct timer_list   sv_temptimer;
    char *          sv_name;
    /* Пул потоков */
    unsigned int        sv_nrpools;
    bool                sv_is_pooled;
    struct svc_pool *   sv_pools;
    /* Функция потока обработчика */
    int         (*sv_threadfn)(void *data);
#if defined(CONFIG_SUNRPC_BACKCHANNEL)
    struct lwq      sv_cb_list;
    bool            sv_bc_enabled;
#endif /* CONFIG_SUNRPC_BACKCHANNEL */
};
\end{lstlisting}

Сервис может быть создан в однопоточном или многопоточном варианте с
использованием функций \code{svc_create} и \code{svc_create_pooled}
(листинг~\ref{lst:svc_create}), которые приводят последующему вызову
\code{__svc_create}. Функция создает и инициализирует структуру
\code{svc_serv}, из примечательных моментов, максимальный размер сообщения
\code{sv_max_payload} имеет значение по умолчанию, равное одной странице (при
использовании значения 0 для параметра \code{bufsize}).

\begin{lstlisting}[caption={Создание сервиса}, label={lst:svc_create}]
struct svc_serv *svc_create(struct svc_program *prog,
                            unsigned int bufsize,
                            int (*threadfn)(void *data));
struct svc_serv *svc_create_pooled(struct svc_program *prog,
                                   unsigned int nprog,
                                   struct svc_stat *stats,
                                   unsigned int bufsize,
                                   int (*threadfn)(void *data));
\end{lstlisting}

Программа, ее версии и процедуры описываются следующими структурами,
представленными на листингах
\refrange{lst:struct_svc_program}{lst:struct_svc_procedure}. Соответствующие
массивы версий и процедур могут быть определены как статически, так и
динамически.

\begin{lstlisting}[caption={Структура программы}, label={lst:struct_svc_program}]
struct svc_program {
    /* Номер программы */
    u32         pg_prog;
    /* Минимальная и максимальная обслуживаемые версии */
    unsigned int        pg_lovers;
    unsigned int        pg_hivers;
    /* Массива версий и его размер */
    unsigned int        pg_nvers;
    const struct svc_version **pg_vers;
    /* Название программы */
    char *          pg_name;
    /* Название класса прграмм, разделяющих аутентификацию,
     * используется общий кеш */
    char *          pg_class;
    /* Пользовательский обработчик аутентификации */
    enum svc_auth_status    (*pg_authenticate)(struct svc_rqst *rqstp);
    /* Функция инициализации контекста потока */
    __be32          (*pg_init_request)(struct svc_rqst *,
                           const struct svc_program *,
                           struct svc_process_info *);
    /* Функция регистрации сервиса (portmapper) */
    int         (*pg_rpcbind_set)(struct net *net,
                          const struct svc_program *,
                          u32 version, int family,
                          unsigned short proto,
                          unsigned short port);
};
\end{lstlisting}

\clearpage

\begin{lstlisting}[caption={Структура версии}, label={lst:struct_svc_version}]
struct svc_version {
    /* Номер версии */
    u32         vs_vers;
    /* Массив процедур и их количество */
    const struct svc_procedure *vs_proc;
    u32                         vs_nproc;
    unsigned long __percpu  *vs_count;
    /* Размер буфера сообщения */
    u32         vs_xdrsize;
    /* Используется ли portmapper */
    bool            vs_hidden;
    /* Игнорируется ли ошибка регистрации */
    bool            vs_rpcb_optnl;
    bool            vs_need_cong_ctrl;
    /* Функция диспетчеризации */
    int         (*vs_dispatch)(struct svc_rqst *rqstp);
};
\end{lstlisting}

\begin{lstlisting}[caption={Структура процедуры}, label={lst:struct_svc_procedure}]
struct svc_procedure {
    /* Реализация функции обработчика процедуры */
    __be32          (*pc_func)(struct svc_rqst *);
    /* Кодирование и декодирование */
    bool            (*pc_decode)(struct svc_rqst *rqstp,
                         struct xdr_stream *xdr); // аргументы
    bool            (*pc_encode)(struct svc_rqst *rqstp,
                         struct xdr_stream *xdr); // результат
    /* Очистка использованных значений */
    void            (*pc_release)(struct svc_rqst *);
    /* Размер аргумента и количество байт, которые должны быть очищены */
    unsigned int        pc_argsize;
    unsigned int        pc_argzero;
    /* Размер результата и максимальный размер сообщения */
    unsigned int        pc_ressize;
    unsigned int        pc_xdrressize;
    unsigned int        pc_cachetype;
    const char *        pc_name;
};
\end{lstlisting}

Инициализация сервиса не приводит к его регистрации, запуску или созданию
транспортной инфраструктуры. Типичная последовательность запуска представлена
на листинге~\ref{lst:svc_start_proc}.

\clearpage

\begin{lstlisting}[caption={Последовательность регистрации и запуска сервиса}, label={lst:svc_start_proc}]
// 1
int svc_bind(struct svc_serv *serv, struct net *net);
// 2
int svc_xprt_create(struct svc_serv *serv, const char *xprt_name,
                    struct net *net, const int family,
                    const unsigned short port, int flags,
                    const struct cred *cred);
// 3
int svc_set_num_threads(struct svc_serv *serv, struct svc_pool *pool,
                        int nrservs);
\end{lstlisting}

Вызов \code{svc_bind}, вопреки названию, не регистрирует сервис у portmapper,
но удаляет существующие записи других сервисов, если они использую номера вновь
созданной программы.

Регистрация же производится при создании нового транспорта в функции
\code{svс_xprt_create}. Зарегистрированные протоколы содержатся в списке
\code{svc_xprt_class_list} и описываются структурой \code{svc_xprt_class}
(листинги~\refrange{lst:struct_svc_xprt_class1}{lst:struct_svc_xprt_class2}). В
настоящий момент возможно использовать только TCP или UDP. Вызов
\code{svc_xprt_create} осуществляет поиск транспорта по его названию,
переданному параметром \code{xprt_name}, после чего вызывается метод
\code{xpo_create}, значение которого совпадает для обоих протоколов ---
\code{svc_create_socket}. Функция создает сокет (\code{__sock_create}),
связывает его с переданным адресом (\code{kernel_bind}) и вызывает
\code{setup_socket}, где и происходит регистрация нового сервиса вызовом
\code{svc_register}, который вызывает метод \code{pg_rpcbind_set} текущей
программы для каждой ее версии. При использовании rpcbind, в ядре определена
стандартная реализация метода --- \code{svc_generic_rpcbind_set}.

\begin{lstlisting}[caption={Структура транспортного протокола (часть 1)}, label={lst:struct_svc_xprt_class1}]
struct svc_xprt_class {
    const char                *xcl_name;
    struct module             *xcl_owner;
    const struct svc_xprt_ops *xcl_ops;
    struct list_head           xcl_list;
    u32                        xcl_max_payload;
    int                        xcl_ident;
};
struct svc_xprt_ops {
    struct svc_xprt *(*xpo_create)(struct svc_serv *,
                                   struct net *net,
                                   struct sockaddr *, int,
                                   int);
\end{lstlisting}
\begin{lstlisting}[caption={Структура транспортного протокола (часть 2)}, label={lst:struct_svc_xprt_class2}]
    struct svc_xprt *(*xpo_accept)(struct svc_xprt *);
    int              (*xpo_has_wspace)(struct svc_xprt *);
    int              (*xpo_recvfrom)(struct svc_rqst *);
    int              (*xpo_sendto)(struct svc_rqst *);
    int              (*xpo_result_payload)(struct svc_rqst *,
                                           unsigned int,
                                           unsigned int);
    void             (*xpo_release_ctxt)(struct svc_xprt *xprt,
                                         void *ctxt);
    void             (*xpo_detach)(struct svc_xprt *);
    void             (*xpo_free)(struct svc_xprt *);
    void             (*xpo_kill_temp_xprt)(struct svc_xprt *);
    void             (*xpo_handshake)(struct svc_xprt *xprt);
};
\end{lstlisting}

После чего остается запустить обработчик функцией \\
\code{svc_set_num_threads}. Вызов создает поток ядра и начинает выполнять
функцию из поля \code{sv_threadfn} сервиса. Ядро не предоставляет готовых
решений для обработчика, поэтому его необходимо определить самостоятельно.
Минимальный пример реализации представлен на листинге \ref{lst:threadfn}.

\begin{lstlisting}[caption={Минимальная реализация функции потока}, label={lst:threadfn}]
int threadfn(void *data)
{
    struct svc_rqst *rqstp = data;
    svc_thread_init_status(rqstp, 0);

    while (!svc_thread_should_stop(rqstp)) {
        svc_recv(rqstp);
    }

    svc_exit_thread(rqstp);

    return 0;
}
\end{lstlisting}

После инициализации в начале обработчика необходимо вызвать функцию
\code{svc_thread_init_status}, передающую статус основному потоку, позволяя ему
продолжить работу. В случае заявления ошибки, функция также останавливает и
поток обработчика. Далее идет основной поток обработки запросов:
\code{svc_thread_should_stop} --- проверяет необходимо ли завершить поток
обработчик; \code{svc_recv} --- получает запрос и вызывает обработчик
\code{svc_process}, если в настоящий момент нет доступных запросов, то поток
переключается в состояние idle.

Работа сервиса прекращается повторным вызовом функции \\
\code{svc_set_num_threads} c параметром \code{nrservs} равным 0. Получив сигнал
к завершению (установкой бита \code{SP_NEED_VICTIM}), поток должен прекратить
работу и вызвать \code{svc_exit_thread} для очистки контекста потока и
информирования основного потока о завершении (сброс бита
\code{SP_VICTIM_REMAINS}).

Обработка запроса происходит внутри функции \code{svc_process}, алгоритм
которой представлен на
рисунках~\refrange{fig:algorithm_svc_process}{fig:algorithm_svc_process_common_2}.

\vspace*{\fill}
\begin{figure}[!h]
    \centering
    \def\svgwidth{\textwidth}
    \input{svc_process_pt1.pdf_tex}
    \caption{Схема алгоритма функции \code{svc_process}}
    \label{fig:algorithm_svc_process}
\end{figure}
\vfill

\clearpage
\vspace*{\fill}
\begin{figure}[!h]
    \centering
    \def\svgwidth{\textwidth}
    \input{svc_process_pt2.pdf_tex}
    \caption{Схема алгоритма функции \code{svc_process_common} (часть 1)}
    \label{fig:algorithm_svc_process_common_1}
\end{figure}
\vfill

\clearpage
\vspace*{\fill}
\begin{figure}[!h]
    \centering
    \def\svgwidth{\textwidth}
    \input{svc_process_pt3.pdf_tex}
    \caption{Схема алгоритма функции \code{svc_process} (часть 2)}
    \label{fig:algorithm_svc_process_common_2}
\end{figure}
\vfill

\clearpage

Шаблонная реализация метода программы \code{pg_init_request} представлена в
функции \code{svc_generic_init_request} и выполняет следующие задачи:
\begin{itemize}
    \item проверка существования запрашиваемой версии и процедуры;
    \item получение структуры \code{svc_procedure} (поле \code{rq_procinfo});
    \item инициализация полей аргумента и результата
          (\code{rq_argp} и \code{rq_resp});
    \item получение функции диспетчеризации (\code{vs_dispatch}).
\end{itemize}

Для функции диспетчеризации не предусмотрено готовое решение, однако из
алгоритма обработки запроса видно, что остается преобразовать полученные
аргументы (\code{pc_decode}), выполнить функцию обработчик запрашиваемой
процедуры (\code{pc_func}) и закодировать результат (\code{pc_encode}).
Минимальный пример такой функции представлен в листинге~\ref{lst:dispatch}.

\begin{lstlisting}[caption={Минимальная реализация функции диспетчеризации}, label={lst:dispatch}]
int dispatch(struct svc_rqst *rqstp)
{
    const struct svc_procedure *proc = rqstp->rq_procinfo;
    __be32 *statp = rqstp->rq_accept_statp;
    if (!proc->pc_decode(rqstp, &rqstp->rq_arg_stream)) {
        *statp = rpc_garbage_args;
        return 0;
    }
    *statp = proc->pc_func(rqstp);
    if (!proc->pc_encode(rqstp, &rqstp->rq_res_stream)) {
        *statp = rpc_system_err;
        return 0;
    }
    return 1;
}
\end{lstlisting}

\subsubsection{Анализ порядка выполнения запроса}

Аналогичные структуры для описания программы определены и для клиента
(листинги~\refrange{lst:struct_rpc_program}{lst:struct_rpc_procedure}).

\clearpage

\begin{lstlisting}[caption={Структура программы}, label={lst:struct_rpc_program}]
struct rpc_program {
    /* Название программы */
    const char *                name;
    /* Номер программы */
    u32                         number;
    /* Массив версий и их количество */
    const struct rpc_version ** version;
    unsigned int                nrvers;
    struct rpc_stat *           stats;
    const char *                pipe_dir_name;
};
\end{lstlisting}

\begin{lstlisting}[caption={Структура версии}, label={lst:struct_rpc_version}]
struct rpc_version {
    /* Номер версии */
    u32                        number;
    /* Массив процедур и их количество */
    const struct rpc_procinfo *procs;
    unsigned int               nrprocs;
    /* Количество вызовов */
    unsigned int              *counts;
};
\end{lstlisting}

\begin{lstlisting}[caption={Структура процедуры}, label={lst:struct_rpc_procedure}]
struct rpc_procinfo {
    /* Номер процедуры */
    u32          p_proc;
    /* Кодирование аргументов */
    kxdreproc_t  p_encode;
    /* Декодирование результатов */
    kxdrdproc_t  p_decode;
    /* Размер */
    unsigned int p_arglen; /* аргумент */
    unsigned int p_replen; /* результат */
    /* Ожидаемое время задержки */
    unsigned int p_timer;
    u32          p_statidx;
    /* Название процедуры */
    const char  *p_name;
};
\end{lstlisting}

Для вызова процедуры необходимо вызвать одну из следующих функций оберток,
представленных в листинге~\ref{lst:rpc_call}. Или же инициализировать и
запустить задачу, описываемую структурой \code{rpc_task}, вручную
(листинг~\ref{lst:rpc_task}).

\begin{lstlisting}[caption={Прототип функций вызова удаленных процедур}, label={lst:rpc_call}]
// Содержимое вызова
struct rpc_message {
    /* Информация о процедуре */
    const struct rpc_procinfo *rpc_proc;
    /* Аргументы */
    void *                     rpc_argp;
    /* Результат */
    void *                     rpc_resp;
    const struct cred *        rpc_cred;
};

// Функции обратного вызова
struct rpc_call_ops {
    void (*rpc_call_prepare)(struct rpc_task *, void *);
    void (*rpc_call_done)(struct rpc_task *, void *);
    void (*rpc_count_stats)(struct rpc_task *, void *);
    void (*rpc_release)(void *);
};

int     rpc_call_async(struct rpc_clnt *clnt,
                       const struct rpc_message *msg,
                       int flags,
                       const struct rpc_call_ops *tk_ops,
                       void *calldata);
int     rpc_call_sync(struct rpc_clnt *clnt,
                      const struct rpc_message *msg, int flags);
\end{lstlisting}

\begin{lstlisting}[caption={Структура \code{rpc_task}}, label={lst:rpc_task}]
struct rpc_task_setup {
    struct rpc_task           *task;
    struct rpc_clnt           *rpc_client;
    struct rpc_xprt           *rpc_xprt;
    struct rpc_cred           *rpc_op_cred;
    const struct rpc_message  *rpc_message;
    const struct rpc_call_ops *callback_ops;
    void                      *callback_data;
    struct workqueue_struct   *workqueue;
    unsigned short             flags;
    signed char                priority;
};

struct rpc_task *rpc_run_task(const struct rpc_task_setup *);
\end{lstlisting}

Вызов процедуры описан конечной машиной состояний. Возможные состояния задачи и
переходы между ними представлены в таблицах~\ref{tbl:rpc_task_states}
и~\ref{tbl:rpc_task_state_transfers}.

\clearpage

\begin{table}[htb!]
    \centering
    \begin{threeparttable}
        \caption{Состояния задачи}
        \begin{tabular}{|r|l|l|}
        \hline
        \multicolumn{1}{|c|}{Номер} & \multicolumn{1}{c|}{Название} & \multicolumn{1}{c|}{Назначение}                                                               \\ \hline
        1                           & call\_start                   & Начальное состояние                                                                           \\ \hline
        2                           & call\_reserve                 & Выделение слота транспортного протокола                                                       \\ \hline
        3                           & call\_reserveresult           & Проверка выделенного слота                                                                    \\ \hline
        4                           & call\_retry\_reserve          & Повторная попытка выделения слота                                                             \\ \hline
        5                           & call\_refresh                 & Обновление удостоверяющей информации                                                          \\ \hline
        6                           & call\_refreshresult           & Проверка удостоверяющей информации                                                            \\ \hline
        7                           & call\_allocate                & Выделение буфера                                                                              \\ \hline
        8                           & call\_encode                  & Кодирование аргументов                                                                        \\ \hline
        9                           & call\_bind                    & Получение порта программы                                                                     \\ \hline
        10                          & call\_connect                 & Соединение с сервером                                                                         \\ \hline
        11                          & call\_bind\_status            & Обработка релультатов rpcbind                                                                 \\ \hline
        12                          & call\_connect\_status         & Обработка результата соединения                                                               \\ \hline
        13                          & call\_transmit                & Отправка запроса                                                                              \\ \hline
        14                          & call\_transmit\_status        & Проверка статуса передачи                                                                     \\ \hline
        15                          & call\_status                  & Проверка статуса запроса                                                                      \\ \hline
        16                          & call\_decode                  & Декодирование результата                                                                      \\ \hline
        17                          & rpc\_exit\_task               & \begin{tabular}[c]{@{}l@{}}Фиктивное состояние завершения\\ и разрушения запроса\end{tabular} \\ \hline
        \end{tabular}
        \label{tbl:rpc_task_states}
    \end{threeparttable}
\end{table}

\vspace{\fill}

\begin{table}[htb!]
    \centering
    \begin{threeparttable}
        \caption{Переходы состояний задачи}
\begin{tabular}{|R{0.15\textwidth}|R{0.08\textwidth}|L{0.65\textwidth}|}
\hline
\multicolumn{1}{|c|}{Инициатор} & \multicolumn{1}{c|}{Цель} & \multicolumn{1}{c|}{Причина (при наличии)}                                                                       \\ \hline
\multirow{2}{*}{1}              & 2                         & Иначе                                                                                                            \\ \cline{2-3} 
                                & 17                        & Клиент выключен                                                                                                  \\ \hline
2                               & 3                         & \multicolumn{1}{c|}{-}                                                                                           \\ \hline
\multirow{3}{*}{3}              & 4                         & Не удалось выделить слот (EAGAIN | ENOMEM)                                                                       \\ \cline{2-3} 
                                & 5                         & Слот выделен                                                                                                     \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
4                               & 3                         & \multicolumn{1}{c|}{-}                                                                                           \\ \hline
5                               & 6                         & \multicolumn{1}{c|}{-}                                                                                           \\ \hline
\multirow{4}{*}{6}              & \multirow{2}{*}{5}        & ENOMEM                                                                                                           \\ \cline{3-3} 
                                &                           & Просроченное удостоверение                                                                                       \\ \cline{2-3} 
                                & 7                         & Актуальное удостоверение                                                                                         \\ \cline{2-3} 
                                & 17                        & Превышено число повторений                                                                                       \\ \hline
\multirow{3}{*}{7}              & 7                         & \begin{tabular}[c]{@{}l@{}}RPC\_IS\_ASYNC\\ и не получен фатальный сигнал\end{tabular}                           \\ \cline{2-3} 
                                & 8                         & Буфер выделен                                                                                                    \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
\end{tabular}
        \label{tbl:rpc_task_state_transfers}
    \end{threeparttable}
\end{table}

\begin{table}[htb!]
    \centering
    \begin{threeparttable}
Продолжение таблицы~\ref{tbl:rpc_task_state_transfers}
\begin{tabular}{|R{0.15\textwidth}|R{0.08\textwidth}|L{0.65\textwidth}|}
\hline
\multirow{5}{*}{8}              & 9                         & Порт сервиса не получен                                                                                          \\ \cline{2-3} 
                                & 10                        & Соединение не установлено                                                                                        \\ \cline{2-3} 
                                & 13                        & \begin{tabular}[c]{@{}l@{}}Кодирование успешно\\ и соединениеустановлено\end{tabular}                            \\ \cline{2-3} 
                                & \multirow{2}{*}{17}       & Не удалось закодировать заголовок                                                                                \\ \cline{3-3} 
                                &                           & Иная ошибка                                                                                                      \\ \hline
\multirow{3}{*}{9}              & 10                        & Порт уже получен                                                                                                 \\ \cline{2-3} 
                                & 11                        & Иначе                                                                                                            \\ \cline{2-3} 
                                & 14                        & Запрос уже отправлен                                                                                             \\ \hline
\multirow{3}{*}{10}             & 12                        & Иначе                                                                                                            \\ \cline{2-3} 
                                & 13                        & Соединение уже установлено                                                                                       \\ \cline{2-3} 
                                & 14                        & Запрос уже отправлен                                                                                             \\ \hline
\multirow{5}{*}{11}             & \multirow{2}{*}{9}        & \begin{tabular}[c]{@{}l@{}}Некритичная ошибка\\ (ENOMEM | EACCESS | ENOBUFS | EAGAIN\\ | ETIMEDOUT)\end{tabular} \\ \cline{3-3} 
                                &                           & \begin{tabular}[c]{@{}l@{}}Сетевая ошибка\\ (если сброшен флаг SOFTCONN)\end{tabular}                            \\ \cline{2-3} 
                                & 10                        & Порт получен                                                                                                     \\ \cline{2-3} 
                                & 14                        & Запрос уже отправлен                                                                                             \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
\multirow{5}{*}{12}             & \multirow{2}{*}{9}        & \begin{tabular}[c]{@{}l@{}}Некритичная ошибка\\ (ENOBUFS | EAGAIN| ETIMEDOUT)\end{tabular}                       \\ \cline{3-3} 
                                &                           & \begin{tabular}[c]{@{}l@{}}Сетевая ошибка\\ (если сброшен флаг SOFTCONN)\end{tabular}                            \\ \cline{2-3} 
                                & 13                        & Соединение установлено                                                                                           \\ \cline{2-3} 
                                & 14                        & Запрос уже отправлен                                                                                             \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
13                              & 14                        & \multicolumn{1}{c|}{-}                                                                                           \\ \hline
\multirow{5}{*}{14}             & 8                         & EBADMSG                                                                                                          \\ \cline{2-3} 
                                & 9                         & ENOMEM | ENOBUFS | EBADSLT | EAGAIN                                                                              \\ \cline{2-3} 
                                & 13                        & \begin{tabular}[c]{@{}l@{}}Сетевая ошибка\\ (если сброшен флаг SOFTCONN)\end{tabular}                            \\ \cline{2-3} 
                                & 15                        & Запрос передан                                                                                                   \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
\multirow{4}{*}{15}             & \multirow{2}{*}{8}        & \begin{tabular}[c]{@{}l@{}}Сетевая ошибка\\ (если сброшен флаг SOFTCONN)\end{tabular}                            \\ \cline{3-3} 
                                &                           & EAGAIN | ENFILE | ENOBUFS | ENOMEM                                                                               \\ \cline{2-3} 
                                & 16                        & Запрос выполнен успешно                                                                                          \\ \cline{2-3} 
                                & 17                        & Иная ошибка                                                                                                      \\ \hline
\end{tabular}
    \end{threeparttable}
\end{table}

\clearpage

\begin{table}[htb!]
    \centering
    \begin{threeparttable}
Продолжение таблицы~\ref{tbl:rpc_task_state_transfers}
\begin{tabular}{|R{0.15\textwidth}|R{0.08\textwidth}|L{0.65\textwidth}|}
\hline
\multirow{4}{*}{16}             & 2                         & EKEYREJECTED                                                                                                     \\ \cline{2-3} 
                                & 8                         & EAGAIN                                                                                                           \\ \cline{2-3} 
                                & \multirow{2}{*}{17}       & Результат декодирован успешно                                                                                    \\ \cline{3-3} 
                                &                           & Иная ошибка                                                                                                      \\ \hline
\end{tabular}
    \end{threeparttable}
\end{table}

Вне зависимости от выбранного подхода предварительно необходимо создать
объект клиента --- структуру \code{rpc_clnt}, вызовом функции \code{rpc_create}
(листинг~\ref{lst:rpc_create}).

\begin{lstlisting}[caption={Создание клиента}, label={lst:rpc_create}]
struct rpc_create_args {
    struct net               *net;
    int                       protocol;
    struct sockaddr          *address;
    size_t                    addrsize;
    const struct rpc_program *program;
    u32                       version;
    rpc_authflavor_t          authflavor;
    const struct cred        *cred;
    unsigned long             flags;

    struct sockaddr          *saddress;
    const struct rpc_timeout *timeout;
    const char               *servername;
    const char               *nodename;
    struct rpc_stat          *stats;
    u32                       prognumber;
    u32                       nconnect;
    char                     *client_name;
    struct svc_xprt          *bc_xprt;
    unsigned int              max_connect;
    struct xprtsec_parms      xprtsec;
    unsigned long             connect_timeout;
    unsigned long             reconnect_timeout;
};

struct rpc_clnt *rpc_create(struct rpc_create_args *args);
\end{lstlisting}

Поведение клиента может быть модифицировано с использованием следующих флагов:
\begin{itemize}
    \item \code{RPC_CLNT_CREATE_HARDRTRY} --- моментальное повторение запроса
          при возникновении ошибки;
    \item \code{RPC_CLNT_CREATE_AUTOBIND} --- порт сервиса получается перед
          каждым повтором запроса;
    \item \code{RPC_CLNT_CREATE_NONPRIVPORT} --- не использовать
          зарезервированные порты (выбирается случайно);
    \item \code{RPC_CLNT_CREATE_NOPING} --- не проверять соединение перед
          созданием;
    \item \code{RPC_CLNT_CREATE_DISCRTRY} --- закрывать соединение перед
          повтором запроса;
    \item \code{RPC_CLNT_CREATE_QUIET} --- не выводить отладочные сообщения;
    \item \code{RPC_CLNT_CREATE_INFINITE_SLOTS} --- использовать максимальное
          количество слотов;
    \item \code{RPC_CLNT_CREATE_NO_IDLE_TIMEOUT} --- не позволять простаивающие
          соединения;
    \item \code{RPC_CLNT_CREATE_NO_RETRANS_TIMEOUT} --- бесконечное ожидание
          ответа;
    \item \code{RPC_CLNT_CREATE_SOFTERR} --- таймаут интерпретируется как
          ошибка;
    \item \code{RPC_CLNT_CREATE_REUSEPORT} --- использовать тот же порт при
          повторе запроса;
    \item \code{RPC_CLNT_CREATE_CONNECTED} --- установить соединение при
          создании клиента.
\end{itemize}

\subsubsection{Анализ преобразования аргументов и результата}

Для кодирования и декодирования сообщения определена структура и операции над
ней для поточного преобразования буфера
(листинги~\refrange{lst:xdr1}{lst:xdr2}).

\begin{lstlisting}[caption={Структура буфера (часть 1)}, label={lst:xdr1}]
/* Структура буфера для принятия и передачи сообщения */
struct xdr_buf {
    struct kvec    head[1],   /* RPC header + non-page data */
                   tail[1];   /* Appended after page data */
    struct bio_vec *bvec;
\end{lstlisting}

\begin{lstlisting}[caption={Структура буфера (часть 2)}, label={lst:xdr2}]
    struct page ** pages;     /* Array of pages */
    unsigned int   page_base, /* Start of page data */
                   page_len,  /* Length of page data */
                   flags;     /* Flags for data disposition */
#define XDRBUF_READ           0x01 /* target of file read */
#define XDRBUF_WRITE          0x02 /* source of file write */
#define XDRBUF_SPARSE_PAGES   0x04 /* Page array is sparse */
    unsigned int   buflen,    /* Total length of storage buffer */
                   len;       /* Length of XDR encoded message */
};

/* Обертка для потоковой обработки */
struct xdr_stream {
    __be32 *p;                /* start of available buffer */
    struct xdr_buf *buf;      /* XDR buffer to read/write */
    __be32 *end;              /* end of available buffer space */
    struct kvec *iov;         /* pointer to the current kvec */
    struct kvec scratch;      /* Scratch buffer */
    struct page **page_ptr;   /* pointer to the current page */
    void *page_kaddr;         /* kmapped address of the current page */
    unsigned int nwords;      /* Remaining decode buffer length */
    struct rpc_rqst *rqst;    /* For debugging */
};
\end{lstlisting}

Для записи данных необходимо получить текущее положение указателя внутри
буфера при помощи функции \code{xdr_reserve_space}. Функция отслеживает
смещение и проверяет достаточно ли места для размещения \code{nbytes}
байт информации.

Далее разработчик может работать с полученным указателем по своему усмотрению,
при этом для типов описанных в спецификации xdr, существуют готовые функции для
кодирования (листинги~\refrange{lst:xdr_encode1}{lst:xdr_encode2}) и их
обертки, позволяющие опустить вызов функции \code{xdr_reserve_space}.

\begin{lstlisting}[caption={Функции для кодирования (часть 1)}, label={lst:xdr_encode1}]
__be32 * xdr_reserve_space(struct xdr_stream *xdr, size_t nbytes);

__be32 *xdr_encode_hyper(__be32 *p, __u64 val);
__be32 *xdr_encode_bool(__be32 *p, u32 n);
int xdr_encode_array2(const struct xdr_buf *buf, unsigned int base,
                      struct xdr_array2_desc *desc);
__be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr,
                                unsigned int len);
__be32 *xdr_encode_opaque(__be32 *p, const void *ptr,
                          unsigned int len);
\end{lstlisting}
\begin{lstlisting}[caption={Функции для кодирования (часть 2)}, label={lst:xdr_encode2}]
__be32 *xdr_encode_string(__be32 *p, const char *s);
__be32 *xdr_encode_array(__be32 *p, const void *s, unsigned int len);

int xdr_stream_encode_bool(struct xdr_stream *xdr, __u32 n);
ssize_t xdr_stream_encode_u32(struct xdr_stream *xdr, __u32 n);
ssize_t xdr_stream_encode_be32(struct xdr_stream *xdr, __be32 n);
ssize_t xdr_stream_encode_be32(struct xdr_stream *xdr, __be32 n);
ssize_t xdr_stream_encode_opaque_inline(struct xdr_stream *xdr,
                                        void **ptr, size_t len);
ssize_t xdr_stream_encode_opaque_fixed(struct xdr_stream *xdr,
                                       const void *ptr, size_t len);
ssize_t xdr_stream_encode_uint32_array(struct xdr_stream *xdr,
                                       const __u32 *array,
                                       size_t array_size);
\end{lstlisting}

Декодирование построено по той же модели --- разработчик запрашивает буфер
определенного размера и считывает из него данные, аналогично библиотека
предоставляет функции обертки для базовых типов данных
(листинги~\refrange{lst:xdr_decode1}{lst:xdr_decode2}).

\begin{lstlisting}[caption={Функции для декодирования (часть 1)}, label={lst:xdr_decode1}]
__be32 *xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes);

__be32 *xdr_decode_hyper(__be32 *p, __u64 *valp);
__be32 *xdr_decode_opaque_fixed(__be32 *p, void *ptr,
                                unsigned int len);
__be32 *xdr_decode_string_inplace(__be32 *p, char **sp,
                                  unsigned int *lenp,
                                  unsigned int maxlen);
int xdr_decode_array2(const struct xdr_buf *buf, unsigned int base,
                      struct xdr_array2_desc *desc);

ssize_t xdr_stream_decode_bool(struct xdr_stream *xdr, __u32 *ptr);
ssize_t xdr_stream_decode_u32(struct xdr_stream *xdr, __u32 *ptr);
ssize_t xdr_stream_decode_u64(struct xdr_stream *xdr, __u64 *ptr);
ssize_t xdr_stream_decode_opaque_fixed(struct xdr_stream *xdr,
                                       void *ptr, size_t len);
ssize_t xdr_stream_decode_opaque_inline(struct xdr_stream *xdr,
                                        void **ptr, size_t maxlen);
ssize_t xdr_stream_decode_uint32_array(struct xdr_stream *xdr,
                                       __u32 *array,
                                       size_t array_size)
ssize_t xdr_stream_decode_opaque(struct xdr_stream *xdr, void *ptr,
                                 size_t size);
\end{lstlisting}
\begin{lstlisting}[caption={Функции для декодирования (часть 2)}, label={lst:xdr_decode2}]
ssize_t xdr_stream_decode_opaque_dup(struct xdr_stream *xdr, void **p,
                                     size_t maxlen, gfp_t gfp_flags);
ssize_t xdr_stream_decode_string(struct xdr_stream *xdr, char *str,
                                 size_t size);
ssize_t xdr_stream_decode_string_dup(struct xdr_stream *xdr, char **s,
                                     size_t maxlen, gfp_t gfp_flags);
\end{lstlisting}

\subsection*{Выводы}

В результате анализа протокола ONC RPC и его реализации в ядре операционной
системы Linux, было установлено, что для генерации кода модулей ядра,
взаимодействующих по модели клиент-сервер, необходимо:
\begin{itemize}
    \item определить соответствующие структуры программ, версий и процедур для клиента
          (\code{rpc_program}, \code{rpc_version}, \code{rpc_procedure}) и
          сервера\\ (\code{svc_program}, \code{svc_version}, \code{svc_procedure}). Описание сервиса состоит из инициализации структуры
          программы, которая должна содержать функции аутентификации,
          инициализации контекста потока и регистрации у \code{portmapper},
          структуры версии, содержащей максимальный размер буфера XDR и функцию
          диспетчеризации, а также процедур, предоставляющих соответствующий
          обработчик и функции для кодирования результата и декодирования
          аргументов;
    \item запустить сервер, путем последовательного вызова функций:
    \begin{enumerate}
        \item \code{svc_create} для создания структуры сервиса;
        \item \code{svc_bind} для удаления записи об используемых номерах программ, версий и процедур
              у \code{portmapper} в случае повторного появления;
        \item \code{svc_xprt_create} для связи сервиса с транспортным протоколом
              и регистрации у \code{portmapper};
        \item \code{svc_set_num_threads} для запуска сервиса;
    \end{enumerate}
    \item произвести вызов, при помощи следующих функций:
    \begin{enumerate}
        \item \code{rpc_cred} для создания структуры клиента;
        \item \code{rpc_call_sync} и \code{rpc_call_async} для вызова удаленной
              процедуры.
    \end{enumerate}
\end{itemize}

